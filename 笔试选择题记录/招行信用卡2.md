1. 关于abstract修饰符
    * 抽象类不能被实例化
    * 不可以用final修饰abstract。因为被final修饰的类不能被重写和继承，abstract的类是抽象类，本身没有实现，只能通过子类来实现，也就是说必须被继承，所以不可以用final修饰abstract.
    * 抽象类可以没有抽象方法
    * 抽象类可以有静态方法
    * 抽象类没有静态的抽象方法

2. 给出一个整型数组，其中除了两个数字只出现一次之外，其他的数字都出现了两次。请找出这两个只出现一次的数字。要求时间复杂度是 O(n) ，空间复杂度是 O(1) 。请简述思路
    答：考察异或运算的性质：任何一个数字异或它自己都等于 0。任何一个数字异或 0 等于该数字本身。
    思路：
    如果题目是只有一个数字只出现一次的话，而不是两个。那么我们可以依次异或数组中的每个数字，那么最终的结果刚好是那个只出现一次的数字。同时满足时间复杂度是 O(n) ，空间复杂度是 O(1) 。
    应该把这个数组拆成两个子数组，每个子数组中，只包含一个只出现一次的数字，而其他数字都出现两次，分而治之。
    解法如下：
    1. 首先，异或所有数字，获得这两个数字的异或结果。由于这两个数字肯定不一样，那么这个异或结果肯定不为 0。换言之，这个结果数字的二进制表示中至少就有一位为 1 。
    2. 我们在异或结果二进制表示中找到第一个为 1 的位的位置，记为第 N 位。
    3. 所有整型长度是一致的，所以我们以第 N 位位基准。再次遍历整个数组，对每个数字进行判断，以第N位是否因为1，进行各自累计异或。
    4. 最终获得两个异或结果，这两个结果就是最终这个两个数字本身。
    整个过程遍历两次，时间复杂度符合 O(n)，空间为是三个异或结果变量，符合要求

3. 在Spring中， bean的作用范围分以下几种
    * singleton: 使用该属性定义Bean时，IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例，singleton是默认的作用域，当定义Bean时，如果没有指定scope配置项，Bean的作用域就默认为singleton
    * prototype: 使用该属性定义Bean时，IOC容器可以创建多个Bean实例，每次返回的都是一个新的实例
    * request: 该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境
    * session: 该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例
    * global session: 该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例

4. resume()方法是负责通过调用suspend()方法而停止的线程

5. 对类的成员访问时，使用的修饰符public,private,protected,以及不写（默认）的区别？
| 修饰符 | 当前类 | 同包 | 子类 | 其他包 |
| ---- | ---- | ---- | ---- | ---- |
| public | y | y | y | y |
| protected | y | y | y | n |
| default | y | y | n | n |
| private | y | n | n | n |

6. 乐观锁和悲观锁是数据库层面的处理并行的一种机制
    * 乐观锁 -- 乐观的认为拿到锁是很容易的，所以先处理业务，到最后一步才申请资源锁，并且打上时间戳 or 版本号
    * 悲观锁 -- 悲观的认为拿到锁是很困难的，所以再执行任务之前必须先拿到锁
    * 乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能

7. 一个类有基类，内部有一个其他类的成员对象，构造函数的执行顺序是怎样的
    * 基类-成员对象-自己的

8. StringBuilder 和 StringBuffer 
    * StringBuffer是线程安全的
    * StringBuilder是非线程安全的
    * 效率比较: String < StringBuffer < StringBuilder




